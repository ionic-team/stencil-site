<h1 id="testing">Testing</h1>
<p>Stencil makes it easy to unit test your component using Jest and the Stencil unit testing framework.
The testing framework requires very little configuration and has a minimal API.
The Stencil unit testing framework can be used to test the rendering of the component
as well as the methods defined on the component class.</p>
<p>Testing is executed with the <code>stencil test</code> command.</p>
<h2 id="setup">Setup</h2>
<p>All of this configuration is included with the Stencil App Starter and the Stencil Component Starter so if you
use one of those templates to start your project, you should not have to add anything. This information is presented
here primarily for informational purposes.</p>
<p><em>TODO: More docs on setup</em></p>
<h3 id="additional-configuration">Additional Configuration</h3>
<p>Stencil will apply defaults from data it has already gathered. For example, Stencil already knows what directories to look through, and what files are spec and e2e files. Jest can still be configured using the same config names, but now using the stencil config <code>testing</code> property.
It&#39;s also recommended to use the typed version of stencil.config .ts so you&#39;ll be able to see the typed configs and descriptions.</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { Config } <span class="hljs-keyword">from</span> <span class="hljs-string">'@stencil/core'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config: Config = {
  testing: {
    testPathIgnorePatterns: [...]
  }
};
</code></pre>
<h2 id="unit-tests">Unit Tests</h2>
<p>Unit testing is for testing small chunks of code at the lowest level. For example, when a method is given X, it should return Y. Unit tests should not be doing full rendering of the component, but rather focused on logic only.</p>
<p>To run unit tests, run <code>stencil test --unit</code>. Files ending in <code>.spec.ts</code> will be executed.</p>
<p>Typically, unit tests will instantiate a component by importing the class, and instantiating and instrumenting it manually.
Since Stencil components are plain JavaScript objects, you can <code>new</code> one up and execute its behavior as such.</p>
<p>An example unit test:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { Foo } <span class="hljs-keyword">from</span> <span class="hljs-string">'./foo'</span>;

describe(<span class="hljs-string">'example'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  it(<span class="hljs-string">'can invoke the add() method'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Foo();
    <span class="hljs-keyword">const</span> sum = foo.add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
    expect(sum).toBe(<span class="hljs-number">5</span>);
  });
});
</code></pre>
<h2 id="end-to-end-aka-rendering-tests">End-To-End (aka Rendering) Tests</h2>
<p>E2E tests verify your components in a real browser. For example, when <code>my-component</code> has the X attribute, the child component then renders the text Y, and expects to receive the event Z. By using Puppeteer for rendering tests (rather than a Node environment simulating how a browser works), your end-to-end tests are able to run within an actual browser in order to give better results.</p>
<p>To run E2E tests, run <code>stencil test --e2e</code>. By default, files ending in <code>.e2e.ts</code> will be executed.</p>
<p>Stencil&#39;s E2E test are provided with the following API, available via <code>@stencil/core/testing</code>.
Most methods are async and return Promises. Use <code>async</code> and <code>await</code> to declutter your tests.</p>
<ul>
<li><code>newE2EPage</code>: Should be invoked at the start of each test to instantiate a new <code>E2EPage</code> object</li>
</ul>
<p><code>E2EPage</code> is a wrapper utility to Puppeteer to simplify writing tests. Some helpful methods on <code>E2EPage</code> include:</p>
<ul>
<li><code>setContent(html: string)</code>: Sets the content of a page. This is where you would include the markup of the component under test.</li>
<li><code>find(selector: string)</code>: Find an element that matches the selector. Similar to <code>document.querySelector</code>.</li>
<li><code>waitForChanges()</code>: Both Stencil and Puppeteer have an asynchronous architecture, which is a good thing for performance. Since all calls are async, it&#39;s required that <code>await page.waitForChanges()</code> is called when changes are made to components.</li>
</ul>
<p>An example E2E test might have the following boilerplate:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { newE2EPage } <span class="hljs-keyword">from</span> <span class="hljs-string">'@stencil/core/testing'</span>;

describe(<span class="hljs-string">'example'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  it(<span class="hljs-string">'should render a foo-component'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> newE2EPage();
    <span class="hljs-keyword">await</span> page.setContent(<span class="hljs-string">`&lt;foo-component&gt;&lt;/foo-component&gt;`</span>);
    <span class="hljs-keyword">const</span> el = <span class="hljs-keyword">await</span> page.find(<span class="hljs-string">'foo-component'</span>);
    expect(el).toBeDefined();
  });
});
</code></pre>
<h2 id="e2e-testing-recipes">E2E Testing Recipes</h2>
<h4 id="find-an-element-in-the-shadow-dom">Find an element in the Shadow DOM</h4>
<p>Use the &quot;piercing&quot; selector <code>&gt;&gt;&gt;</code> to query for an object inside a component&#39;s shadow root:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> el = <span class="hljs-keyword">await</span> page.find(<span class="hljs-string">'foo-component &gt;&gt;&gt; .close-button'</span>);
</code></pre>
<h4 id="set-a-prop-on-a-component">Set a @Prop() on a component</h4>
<p>Use <code>page.$eval</code> (part of the Puppeteer API) to set props or otherwise manipulate a component:</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// create a new puppeteer page</span>
<span class="hljs-comment">// load the page with html content</span>
<span class="hljs-keyword">await</span> page.setContent(<span class="hljs-string">`
      &lt;prop-cmp&gt;&lt;/prop-cmp&gt;
    `</span>);

<span class="hljs-comment">// select the "prop-cmp" element</span>
<span class="hljs-comment">// and run the callback in the browser's context</span>
<span class="hljs-keyword">await</span> page.$<span class="hljs-built_in">eval</span>(<span class="hljs-string">'prop-cmp'</span>, <span class="hljs-function">(<span class="hljs-params">elm: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
  <span class="hljs-comment">// within the browser's context</span>
  <span class="hljs-comment">// let's set new property values on the component</span>
  elm.first = <span class="hljs-string">'Marty'</span>;
  elm.lastName = <span class="hljs-string">'McFly'</span>;
});

<span class="hljs-comment">// we just made a change and now the async queue need to process it</span>
<span class="hljs-comment">// make sure the queue does its work before we continue</span>
<span class="hljs-keyword">await</span> page.waitForChanges();
</code></pre>
<h4 id="call-a-method-on-a-component">Call a @Method() on a component</h4>
<pre><code class="lang-ts"><span class="hljs-keyword">const</span> elm = <span class="hljs-keyword">await</span> page.find(<span class="hljs-string">'method-cmp'</span>);
elm.setProperty(<span class="hljs-string">'someProp'</span>, <span class="hljs-number">88</span>);
<span class="hljs-keyword">const</span> methodRtnValue = <span class="hljs-keyword">await</span> elm.callMethod(<span class="hljs-string">'someMethod'</span>);
</code></pre>
<h4 id="type-inside-an-input-field">Type inside an input field</h4>
<pre><code class="lang-ts"><span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> newE2EPage({
  html: <span class="hljs-string">`
      &lt;dom-interaction&gt;&lt;/dom-interaction&gt;
    `</span>
});

<span class="hljs-keyword">const</span> input = <span class="hljs-keyword">await</span> page.find(<span class="hljs-string">'dom-interaction &gt;&gt;&gt; .input'</span>);

<span class="hljs-keyword">let</span> value = <span class="hljs-keyword">await</span> input.getProperty(<span class="hljs-string">'value'</span>);
expect(value).toBe(<span class="hljs-string">''</span>);

<span class="hljs-keyword">await</span> input.press(<span class="hljs-string">'8'</span>);
<span class="hljs-keyword">await</span> input.press(<span class="hljs-string">'8'</span>);
<span class="hljs-keyword">await</span> input.press(<span class="hljs-string">' '</span>);

<span class="hljs-keyword">await</span> page.keyboard.down(<span class="hljs-string">'Shift'</span>);
<span class="hljs-keyword">await</span> input.press(<span class="hljs-string">'KeyM'</span>);
<span class="hljs-keyword">await</span> input.press(<span class="hljs-string">'KeyP'</span>);
<span class="hljs-keyword">await</span> input.press(<span class="hljs-string">'KeyH'</span>);
<span class="hljs-keyword">await</span> page.keyboard.up(<span class="hljs-string">'Shift'</span>);
</code></pre>
<h4 id="checking-the-text-of-a-rendered-component">Checking the text of a rendered component</h4>
<pre><code class="lang-ts"><span class="hljs-keyword">await</span> page.setContent(<span class="hljs-string">`
      &lt;prop-cmp first="Marty" last-name="McFly"&gt;&lt;/prop-cmp&gt;
    `</span>);

<span class="hljs-keyword">const</span> elm = <span class="hljs-keyword">await</span> page.find(<span class="hljs-string">'prop-cmp &gt;&gt;&gt; div'</span>);
expect(elm).toEqualText(<span class="hljs-string">'Hello, my name is Marty McFly'</span>);
</code></pre>
<h4 id="checking-a-component-s-html">Checking a component&#39;s HTML</h4>
<p>For shadowRoot content:</p>
<pre><code class="lang-ts">        expect(el.shadowRoot).toEqualHtml(<span class="hljs-string">`&lt;div&gt;
        &lt;div class=\"nav-desktop\"&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;`</span>);
    });
</code></pre>
<p>For non-shadow content:</p>
<pre><code class="lang-ts">        expect(el).toEqualHtml(<span class="hljs-string">`&lt;div&gt;
        &lt;div class=\"nav-desktop\"&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;`</span>);
    });
</code></pre>
